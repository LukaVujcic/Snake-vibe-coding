var p=Object.defineProperty;var y=(l,e,t)=>e in l?p(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var i=(l,e,t)=>y(l,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const h of o.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&s(h)}).observe(document,{childList:!0,subtree:!0});function t(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=t(r);fetch(r.href,o)}})();class f{constructor(e,t,s=4){this.fillColor=e,this.strokeColor=t,this.cornerRadius=s}draw(e,t,s,r,o,h=0){e.save(),h!==0&&(e.translate(t+r/2,s+o/2),e.rotate(h),e.translate(-(t+r/2),-(s+o/2)));const a=Math.min(this.cornerRadius,r/2,o/2);e.beginPath(),e.moveTo(t+a,s),e.lineTo(t+r-a,s),e.quadraticCurveTo(t+r,s,t+r,s+a),e.lineTo(t+r,s+o-a),e.quadraticCurveTo(t+r,s+o,t+r-a,s+o),e.lineTo(t+a,s+o),e.quadraticCurveTo(t,s+o,t,s+o-a),e.lineTo(t,s+a),e.quadraticCurveTo(t,s,t+a,s),e.closePath(),e.fillStyle=this.fillColor,e.fill(),this.strokeColor&&(e.strokeStyle=this.strokeColor,e.lineWidth=1.5,e.stroke()),e.restore()}}class v{constructor(e,t){this.image=e,this.spriteRect=t}draw(e,t,s,r,o,h=0){if(e.save(),h!==0&&(e.translate(t+r/2,s+o/2),e.rotate(h),e.translate(-(t+r/2),-(s+o/2))),this.spriteRect){const{sx:a,sy:d,sw:m,sh:w}=this.spriteRect;e.drawImage(this.image,a,d,m,w,t,s,r,o)}else e.drawImage(this.image,t,s,r,o);e.restore()}}const u=class u{constructor(){i(this,"textures",new Map)}async loadTextures(){const e=Object.entries(u.SPRITE_CONFIG).map(([t,s])=>this.loadImage(s.path).then(r=>{this.textures.set(t,new v(r,s.spriteRect))}).catch(()=>{console.warn(`[TextureManager] Failed to load sprite for "${t}", using fallback.`)}));await Promise.all(e)}getTexture(e){if(this.textures.has(e))return this.textures.get(e);const t=u.FALLBACK_COLORS[e];return t?new f(t[0],t[1]):new f("#888888")}loadImage(e){return new Promise((t,s)=>{const r=new Image;r.onload=()=>t(r),r.onerror=s,r.src=e})}};i(u,"SPRITE_CONFIG",{}),i(u,"FALLBACK_COLORS",{"snake-head":["#22d3ee","#0891b2"],"snake-body":["#0e7490","#0891b2"],"snake-tail":["#164e63","#0891b2"],food:["#f43f5e","#be123c"],background:["#060b14"],grid:["#0d1526"]});let g=u;const c=class c{constructor(e,t){this.x=e,this.y=t}add(e){return new c(this.x+e.x,this.y+e.y)}equals(e){return this.x===e.x&&this.y===e.y}clone(){return new c(this.x,this.y)}toAngle(){return Math.atan2(this.y,this.x)}};i(c,"UP",new c(0,-1)),i(c,"DOWN",new c(0,1)),i(c,"LEFT",new c(-1,0)),i(c,"RIGHT",new c(1,0));let n=c;class S{constructor(e,t=3){i(this,"segments");i(this,"_direction");i(this,"pendingGrowth",0);this.segments=[];for(let s=0;s<t;s++)this.segments.push(new n(e.x-s,e.y));this._direction=n.RIGHT}get head(){return this.segments[0]}get body(){return this.segments}get direction(){return this._direction}setDirection(e){e.x===-this._direction.x&&e.y===-this._direction.y||(this._direction=e)}move(){const e=this.head.add(this._direction);this.segments.unshift(e),this.pendingGrowth>0?this.pendingGrowth--:this.segments.pop()}grow(){this.pendingGrowth++}checkSelfCollision(){const e=this.head;return this.segments.slice(1).some(t=>t.equals(e))}getSegmentDirection(e){if(e===0)return this._direction;const t=this.segments[e],s=this.segments[e-1];return new n(s.x-t.x,s.y-t.y)}reset(e,t=3){this.segments=[];for(let s=0;s<t;s++)this.segments.push(new n(e.x-s,e.y));this._direction=n.RIGHT,this.pendingGrowth=0}}class C{constructor(e,t="food"){i(this,"_position");i(this,"_textureKey");this._position=e,this._textureKey=t}get position(){return this._position}get textureKey(){return this._textureKey}respawn(e,t,s){let r,o=0;const h=e*t;do{const a=Math.floor(Math.random()*e),d=Math.floor(Math.random()*t);r=new n(a,d),o++}while(s.some(a=>a.equals(r))&&o<h);this._position=r}}class T{constructor(e,t,s){this.cols=e,this.rows=t,this.cellSize=s}get pixelWidth(){return this.cols*this.cellSize}get pixelHeight(){return this.rows*this.cellSize}isOutOfBounds(e){return e.x<0||e.x>=this.cols||e.y<0||e.y>=this.rows}get center(){return new n(Math.floor(this.cols/2),Math.floor(this.rows/2))}}class R{checkWallCollision(e,t){return t.isOutOfBounds(e.head)}checkSelfCollision(e){return e.checkSelfCollision()}checkFoodCollision(e,t){return e.head.equals(t.position)}}class b{constructor(e,t,s){i(this,"rafId",0);i(this,"lastTime",0);i(this,"accumulator",0);i(this,"running",!1);i(this,"loop",e=>{if(!this.running)return;const t=e-this.lastTime;for(this.lastTime=e,this.accumulator+=t;this.accumulator>=this.tickRate;)this.onUpdate(),this.accumulator-=this.tickRate;this.onRender(),this.rafId=requestAnimationFrame(this.loop)});this.tickRate=e,this.onUpdate=t,this.onRender=s}start(){this.running||(this.running=!0,this.lastTime=performance.now(),this.accumulator=0,this.rafId=requestAnimationFrame(this.loop))}stop(){this.running=!1,cancelAnimationFrame(this.rafId)}}const k={ArrowUp:n.UP,ArrowDown:n.DOWN,ArrowLeft:n.LEFT,ArrowRight:n.RIGHT,w:n.UP,s:n.DOWN,a:n.LEFT,d:n.RIGHT};class E{constructor(e){i(this,"_direction",n.RIGHT);i(this,"_nextDirection",n.RIGHT);i(this,"_onStart");i(this,"handleKeyDown",e=>{var r;if(e.key==="Enter"||e.key===" "){e.preventDefault(),(r=this._onStart)==null||r.call(this);return}const t=k[e.key];if(!t)return;e.preventDefault(),t.x===-this._direction.x&&t.y===-this._direction.y||(this._nextDirection=t)});this._onStart=e}get direction(){return this._direction=this._nextDirection,this._direction}start(){window.addEventListener("keydown",this.handleKeyDown)}stop(){window.removeEventListener("keydown",this.handleKeyDown)}reset(){this._direction=n.RIGHT,this._nextDirection=n.RIGHT}}class I{constructor(e,t){i(this,"_score",0);i(this,"_bestScore",0);this.scoreEl=e,this.bestEl=t,this.updateDOM()}get score(){return this._score}get bestScore(){return this._bestScore}increment(){this._score++,this._score>this._bestScore&&(this._bestScore=this._score),this.updateDOM()}reset(){this._score=0,this.updateDOM()}updateDOM(){this.scoreEl.textContent=String(this._score),this.bestEl.textContent=String(this._bestScore)}}class O{constructor(e,t,s){i(this,"ctx");this.canvas=e,this.textureProvider=t,this.board=s;const r=e.getContext("2d");if(!r)throw new Error("Could not get 2D canvas context");this.ctx=r,e.width=s.pixelWidth,e.height=s.pixelHeight}get width(){return this.canvas.width}get height(){return this.canvas.height}clear(){this.ctx.clearRect(0,0,this.width,this.height)}drawBackground(){this.textureProvider.getTexture("background").draw(this.ctx,0,0,this.width,this.height);const t=this.textureProvider.getTexture("grid"),{cellSize:s,cols:r,rows:o}=this.board;for(let h=0;h<r;h++)for(let a=0;a<o;a++){const d=h*s+1,m=a*s+1;t.draw(this.ctx,d,m,s-2,s-2)}}drawCell(e,t,s=0){const r=this.textureProvider.getTexture(t),o=1,h=e.x*this.board.cellSize+o,a=e.y*this.board.cellSize+o,d=this.board.cellSize-o*2;r.draw(this.ctx,h,a,d,d,s)}}class _{constructor(e,t,s){i(this,"snake");i(this,"food");i(this,"board");i(this,"collisionDetector");i(this,"gameLoop");i(this,"inputHandler");i(this,"scoreManager");i(this,"renderer");i(this,"state","IDLE");i(this,"overlay");i(this,"overlayTitle");i(this,"overlayMessage");i(this,"overlayScore");this.board=new T(s.cols,s.rows,s.cellSize),this.snake=new S(this.board.center),this.food=new C(new n(Math.floor(s.cols*.75),Math.floor(s.rows/2))),this.collisionDetector=new R,this.scoreManager=new I(document.getElementById("score-display"),document.getElementById("best-display")),this.overlay=document.getElementById("overlay"),this.overlayTitle=document.getElementById("overlay-title"),this.overlayMessage=document.getElementById("overlay-message"),this.overlayScore=document.getElementById("overlay-score"),this.inputHandler=new E(()=>this.handleStartRequest()),this.inputHandler.start(),this.renderer=new O(e,t,this.board),this.gameLoop=new b(s.tickRate,()=>this.update(),()=>this.render()),this.showIdleScreen(),this.gameLoop.start()}handleStartRequest(){(this.state==="IDLE"||this.state==="GAME_OVER")&&this.startGame()}startGame(){this.snake.reset(this.board.center),this.food.respawn(this.board.cols,this.board.rows,this.snake.body),this.scoreManager.reset(),this.inputHandler.reset(),this.state="RUNNING",this.hideOverlay()}update(){if(this.state!=="RUNNING")return;const e=this.inputHandler.direction;if(this.snake.setDirection(new n(e.x,e.y)),this.snake.move(),this.collisionDetector.checkWallCollision(this.snake,this.board)){this.triggerGameOver();return}if(this.collisionDetector.checkSelfCollision(this.snake)){this.triggerGameOver();return}this.collisionDetector.checkFoodCollision(this.snake,this.food)&&(this.snake.grow(),this.scoreManager.increment(),this.food.respawn(this.board.cols,this.board.rows,this.snake.body))}render(){this.renderer.clear(),this.renderer.drawBackground(),this.renderer.drawCell(this.food.position,this.food.textureKey);const e=this.snake.body;for(let t=0;t<e.length;t++){let s,r=0;t===0?(s="snake-head",r=this.snake.direction.toAngle()):t===e.length-1?(s="snake-tail",r=this.snake.getSegmentDirection(t).toAngle()):(s="snake-body",r=this.snake.getSegmentDirection(t).toAngle()),this.renderer.drawCell(e[t],s,r)}}triggerGameOver(){this.state="GAME_OVER",this.showGameOverScreen()}showIdleScreen(){this.overlayTitle.textContent="SNAKE",this.overlayTitle.className="",this.overlayMessage.textContent="Press ENTER or SPACE to start",this.overlayScore.classList.add("hidden"),this.overlay.classList.remove("hidden")}showGameOverScreen(){this.overlayTitle.textContent="GAME OVER",this.overlayTitle.className="game-over",this.overlayMessage.textContent="Press ENTER or SPACE to restart",this.overlayScore.textContent=`SCORE: ${this.scoreManager.score}`,this.overlayScore.classList.remove("hidden"),this.overlay.classList.remove("hidden")}hideOverlay(){this.overlay.classList.add("hidden")}}const G={cols:20,rows:20,cellSize:28,tickRate:140};async function M(){const l=document.getElementById("gameCanvas");if(!l)throw new Error("Canvas element not found");const e=new g;await e.loadTextures(),new _(l,e,G)}M().catch(console.error);
